-- classDescription
Window of the game where the state gets rendered
all the game UI logic will be handled here.

-- fields

# private JFrame frame;
# private BufferedImage image;
# private Canvas canvas;
# private BufferedStrategy bs;
# private Graphics g;

-- constructor

# public Window(GameContainer gc)[constructor][GameContainer->class]
[description]:
Window parameterized constructor which takes GameContainer as agrument 
and initialize class fields with defaults.

# ln1 -> 
instantiate (image[field]) by calling 
the parameterized BufferedImage
class constructor by passing agrs as
(integerWidth, integerHeight, bufferImageType). 
[image-stored-in-ram-buffer]

# ln2 -> 
instantiate (canvas[field]) by calling the default
Canvas class constructor.
[clean-slate-to-paint-on]

# ln3 -> 
instantiate (s[localVariable]) by calling parameterized Dimension 
class constructor by passing args as 
(integerWidth, integerHeight)
[create-rect-on-slate]

# ln4 to ln6 -> 
use the setter provided by canvas object i.e., 
setPreferredSize(Dimension),
setMaximumSize(Dimension),
seetMinimumSize(Dimension).
FORALL[self-explanatory]

# ln7 -> 
instantiate (frame[field]) by calling parameterized JFrame
class constructor by passing args as
(stringTitle)
[screeining-of-slate]

# ln8 ->
use the setter provided by frame object i.e.,
setDefaultCloseOperation(options) 
[exit-when-click-on-cross-&-halt-the-programe]

# ln9 ->
use the setter provided by frame object i.e.,
setLayout(BorderLayout)
[self-explanatory]

# ln10 ->
use the add method of frame object to add the canvas
and pass BorderLayout position i.e.,
add(Canvas, positionString)
[add-canvas-with-provided-position]

# ln11 to ln14 ->
* use the pack method to set the JFrame window size wrap over
the canvas layout and fit exactly to the canvas.
[self-explanatory]
* use setLocationRelativeTo(configObject) will show up on top left 
by default passing it null makes it show up on the center.
[self-explanatory]
* use setResizable(boolean) to make the window not resize and vice-versa.
[self-explanatory]
* use setVisible(boolean) to make the window show up or not.
[self-explanatory]

# ln15 ->
use the createBufferStrategy(integer) method of 
the canvas object to create a buffer strategy.
[self-explanatory]

# ln16 ->
use the getBufferStrategy() method of canvas object
to initialize bs object.
[self-explanatory]

# ln17 ->
use the getDrawGraphics() method of bs object to 
initialize g object.
[self-explanatory]

[code]:
// gc.getWidth()[GameContainer->method]
// gc.getHeight()[GameContainer->method]
// gc.getScale()[GameContainer->method]
// gc.getTitle()[GameContainer->method]

# ln1 -> 
this.image = new BufferedImage(gc.getWidth(), gc.getHeight(), 
                BufferedImage.TYPE_INT_RGB);

# ln2 -> 
this.canvas = new Canvas();

# ln3 -> 
s = new Dimension((int)(gc.getWidth() * gc.getScale()), 
        (int)(gc.getHeight() * gc.getScale()));

# ln4 to ln6 -> 
this.canvas.setPreferredSize(s);
this.canvas.setMaximumSize(s);
this.canvas.seetMinimumSize(s);

# ln7 ->
this.frame = new JFrame(gc.getTitle());

# ln8 ->
this.frame.setDefaultCloseOperation(JFrame.EXIT_ON_CLOSE);

# ln9 ->
this.frame.setLayout(new BorderLayout());

# ln10 ->
this.frame.add(canvas, BorderLayout.CENTER);

# ln11 to ln14 ->
this.frame.pack();
this.frame.setLayoutRelativeTo(null);
this.frame.setResizable(false);
this.frame.setVisible(true);

# ln15 ->
this.canvas.createBufferStrategy(2);

# ln16 ->
this.bs = this.canvas.getBufferStrategy();

# ln17 ->
this.g = this.bs.getDrawGraphics();

-- methods

public void update()[method]:
[description]:
use the drawImage method provided by g object and
pass agrs as (BufferedImage, startX, startY, 
                endX, endY, observer).
use show method of bs object.

[code]:
g.drawImage(image, 0, 0, canvas.getWidth(), 
                canvas.getHeight(), null);
bs.show();

-- methods -> getters and setters

@name -> {Canvas->!setter, image->!setter, frame->!setter}

# public int get{name}()[method]
[description]:
Will return the value of the field {name}.

# public void set{name}(int new{name})[method]
[description]:
Will assign the new value to the field {name}.
